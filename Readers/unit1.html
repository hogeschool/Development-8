<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>Introduction to functional programming</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'HelveticaNeue-Light', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <h1 id="introduction-to-functional-programming">Introduction to functional programming</h1>
<p>Functional programming is a programming paradigm that is profoundly different from the imperative paradigm. This programming paradigm grants additional properties on the code that help the programmer to write code that is maintainable and correct. For this reason also imperative languages widely used in the industry have been including functional programming construct during the last decades: C#, C++, Java, Javascript, Typescript all provide means of writing programs in terms  of functional programming abstractions, and some of them even integrated type systems that are as expressive as those of Haskell or CamL. It is evident that functional programming trascendended the role of a tool used only by researchers and pioneers of programming and is becoming more and more a reality in the industry.</p>
<p>The goal of this unit is to show the reader a comparison between the model of imperative programming, which was explained during the Development courses of the first year, and the functional paradigm. We then proceed to define the semantics of a functional programming language, namely F#, and we present its main features.</p>
<h2 id="imperative-programming-vs-functional-programming">Imperative programming vs functional programming</h2>
<p>An imperative program is made of a sequence of instructions or commands that alter the memory, which is in general refered to also as <em>State</em>. In the introductory programming courses of the first year we said that a program is evaluated through its <em>semantics</em>, that is a set of rules defining the behaviour of each construct in the language. In general, in an imperative programming language, each of these rules processes a program and in general returns a new program and a new state.</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>(</mo><mo>⟨</mo><mi>P</mi><mo>⟩</mo><mo separator="true">,</mo><mi>S</mi><mo>)</mo><mo>⇒</mo><mo>⟨</mo><msup><mi>P</mi><mo mathvariant="normal">′</mo></msup><mo>⟩</mo><mo separator="true">,</mo><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">eval(\langle P \rangle ,S) \Rightarrow \langle P &#x27;\rangle,S&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mopen">⟨</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>The new program is generally returned because the evaluation of a single instruction might, in general, require multiple steps. The new state is due to the fact that some of the instructions might perform operations in memory and thus change the state.</p>
<p>In the following more advanced courses we further extended the model of state by allowing <em>scoping</em> and differentiate between <em>stack</em> and <em>heap</em>, but the underlying logic does not change in its substance. Indeed the evaluation of a program with stack and heap is given by the following rule:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>(</mo><mo>⟨</mo><mi>I</mi><mo separator="true">;</mo><mi>J</mi><mo>⟩</mo><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>H</mi><mo>)</mo><mo>⇒</mo><mo>⟨</mo><msup><mi>I</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">;</mo><mi>J</mi><mo>⟩</mo><mo separator="true">,</mo><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>H</mi><mo mathvariant="normal">′</mo></msup><mtext> where </mtext><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>(</mo><mo>⟨</mo><mi>I</mi><mo>⟩</mo><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>H</mi><mo>)</mo><mo>⇒</mo><mo>⟨</mo><msup><mi>I</mi><mo mathvariant="normal">′</mo></msup><mo>⟩</mo><mo separator="true">,</mo><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>H</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">eval (\langle I;J\rangle,S,H) \Rightarrow \langle I&#x27;;J\rangle,S&#x27;,H&#x27; \text{ where } eval(\langle I\rangle,S,H) \Rightarrow \langle I&#x27;\rangle,S&#x27;,H&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mopen">⟨</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> where </span></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mopen">⟨</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>In this context the program uses a shared memory that is read and written by each instruction. This means that the order that we use to execute the instructions change the behaviour of the program. So two different programs with the same instructions in different order might produce two different results. For example consider the following two code snippets in Python:</p>
<pre><code class="language-python"><div>x = <span class="hljs-number">5</span>
y = <span class="hljs-number">2</span>
x = x + <span class="hljs-number">1</span>
y = x - y
</div></code></pre>
<pre><code class="language-python"><div>x = <span class="hljs-number">5</span>
y = <span class="hljs-number">2</span>
y = x - y
x = x + <span class="hljs-number">1</span>
</div></code></pre>
<p>In the first case, at the end of the execution, the state is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>x</mi><mo>:</mo><mo>=</mo><mn>6</mn><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mo>=</mo><mn>4</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\lbrace x := 6, y := 4 \rbrace</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">}</span></span></span></span> while in the second case the state is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mi>x</mi><mo>:</mo><mo>=</mo><mn>6</mn><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mo>=</mo><mn>3</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\lbrace x := 6, y := 3 \rbrace</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">}</span></span></span></span>. The different results are determined by the different order of execution of line 3 and 4 in the two programs, wich is inverted in the second version. This creates undesirable side effect not only in single-thread programs but also in multi-thread ones. Getting rid of the problems related to shared memory often grants additional correctness properties and benefits, for example, parallelization and code maintainability. One very straightforward solution is getting rid of the mutable state itself, and this is where functional programming comes into play.</p>
<p>The computation in functional programming does not rely on the notion of state, and for this reason it is defined as <em>stateless</em> or <em>immutable</em>. The computation in a functional programming language consists of expression evaluations. Recalling the development courses of last year, we defined in the semantics a special semantics, called <code>eval_expr</code>, to process expression: its evaluation did not change the state of the program (even though we were in the context of imperative programming) because the result was simply a value resulting from a computation.</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>_</mtext><mi>e</mi><mi>x</mi><mi>p</mi><mi>r</mi><mo>(</mo><mo>⟨</mo><mi>E</mi><mo>⟩</mo><mo separator="true">,</mo><mi>S</mi><mo>)</mo><mo>⇒</mo><mo>⟨</mo><msup><mi>E</mi><mo mathvariant="normal">′</mo></msup><mo>⟩</mo></mrow><annotation encoding="application/x-tex">eval\text{\textunderscore}expr(\langle E\rangle, S) \Rightarrow \langle E&#x27;\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord text"><span class="mord">_</span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mopen">⟨</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">⟩</span></span></span></span></p>
<p>The stateless model of computation grants an important property called <em>referential transparency</em>. Referential transparency grants that, at any point of a program, we can replace an expression with its value without changing the final result of the computation. In the following program</p>
<pre><code class="language-python"><div>x = <span class="hljs-number">5</span>
x = x - <span class="hljs-number">2</span>
y = x + <span class="hljs-number">3</span>
</div></code></pre>
<p>we cannot replace, for instance, <code>x</code> with 5, which is the value we assign to it in the first line. For example, if we replace <code>x</code> with 5 in the last line of code, <code>y</code> would get the value 8. But this is clearly wrong, because if we execute all the statements in the program, at line 2 the value of  <code>x</code> becomse 3, and thus <code>y</code> gets 6 after executing line 3. In a referential transparent program this does not happen: we are sure that if, at any moment, we know already the value of an expression and we replace it with its value we do not alter the result of the program execution. A consequence of this is also that, for instance, calling two different functions in a different order does not change the final result of a program, while in general this is not true in imperative programming.</p>
<p>Being intrinsecally different from imperative programming, functional programming will require a completely different computational model which is not based on instructions and state transitions. This underlying computational model is called <em>Lambda Calculus</em>.</p>
<h2 id="untyped-lambda-calculus">Untyped lambda calculus</h2>
<p>Lambda calculus is a computational model that is at the foundation of the semantics of all functional programming languages. Lambda calculus is radically different from the model above, but it has the same expressive power. This means that everything that we can compute in an imperative language can be computed also in a functional language. In this section we focus on its untyped version but later on we will extend it with a type system. Since the focus of this course is functional programming and not a theoretical course on lambda calculus we will skip some details. For example we will assume that the encoding of numbers and boolean values is already available in lambda calculus, and that arithmetic and boolean operations are possible, without formally showing their implementation in lambda calculus itself. We will just compute the result of arithmetic and boolean experssion as we would normally do.</p>
<p>Lambda calculus is made of three syntactic elements:</p>
<ul>
<li><em>Variables</em> as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, ...</li>
<li><em>Abstractions</em>, that are function declarations with <strong>one</strong> parameter, in the form <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\text{fun} \; x \rightarrow t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> is a variable and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> is the body of the function.</li>
<li><em>Applications</em> (calling a function with one argument) in the form <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mtext>&ThickSpace;</mtext><mi>u</mi></mrow><annotation encoding="application/x-tex">t \; u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">u</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> is a function being called and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> is its argument. Both <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> can be themselves complex expressions in lambda calculus.</li>
</ul>
<p>Note that in lambda calculus abstractions can be passed as values, thus functions can be passed as arguments of other functions.</p>
<p>Now that we have defined the syntax of the language, we have to define its <em>semantics</em>, that is how its elements behave. This will be done through evaluation rules, in the same fashion as we did in previous development courses.</p>
<p><strong>Variables</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mi>x</mi><mo>⇒</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">eval \; x \Rightarrow x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></p>
<p>This rule states that variables cannot be further evaluated.</p>
<p><strong>Abstractions</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>t</mi><mo>)</mo><mo>⇒</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">eval \; (\text{fun} \; \; x \rightarrow t) \Rightarrow (\text{fun} \; x \rightarrow t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></p>
<p>This rule states that abstractions <strong>alone</strong> cannot be further evaluated.</p>
<p><strong>Substitution rule</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>t</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mi>u</mi><mo>⇒</mo><mi>t</mi><mo>[</mo><mi>x</mi><mo>↦</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">eval \; (\text{fun} \; x \rightarrow t) \; u \Rightarrow t[x \mapsto u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span></p>
<p>This rule states that whenever we call an abstraction with a parameter <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>, the result is the body of the abstraction where its argument variable is replaced by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span></p>
<p><strong>Example</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>x</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mi>A</mi><mo>⇒</mo><mi>x</mi><mo>[</mo><mi>x</mi><mo>↦</mo><mi>A</mi><mo>]</mo><mo>⇒</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">eval \; (\text{fun} \; x \rightarrow x) \; A \Rightarrow x[x \mapsto A] \Rightarrow A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mi>x</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>x</mi><mo>)</mo><mo>⇒</mo></mrow><annotation encoding="application/x-tex">eval \; (\text{fun} \; x \rightarrow \text{fun} \; y \rightarrow x) \; (\text{fun} \; x \rightarrow x) \Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mi>x</mi><mo>)</mo><mo>[</mo><mi>x</mi><mo>↦</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>x</mi><mo>)</mo><mo>]</mo><mo>⇒</mo></mrow><annotation encoding="application/x-tex">(\text{fun} \; y \rightarrow x)[x \mapsto (\text{fun} \; x \rightarrow x)] \Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{fun} \; y \rightarrow (\text{fun} \; x \rightarrow x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
<p><strong>Function application</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mo>(</mo><mi>t</mi><mtext>&ThickSpace;</mtext><mi>u</mi><mo>)</mo><mo>⇒</mo><mi>v</mi><mtext> where </mtext><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mi>t</mi><mo>⇒</mo><msup><mi>t</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mi>u</mi><mo>⇒</mo><msup><mi>u</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><msup><mi>t</mi><mo mathvariant="normal">′</mo></msup><mtext>&ThickSpace;</mtext><msup><mi>u</mi><mo mathvariant="normal">′</mo></msup><mo>⇒</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">eval \; (t \; u) \Rightarrow v \text{ where } eval \; t \Rightarrow t&#x27;, eval \; u \Rightarrow u&#x27;, eval \; t&#x27; \; u&#x27; \Rightarrow v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord text"><span class="mord"> where </span></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></p>
<p>This rule states that, whenever we have a function application where the left term is not immediately an abstraction, we have to evaluate the terms left-to-right and then use their evaluation to compute the final result.</p>
<p><strong>Example</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mo>(</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>x</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mi>A</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mo>(</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mi>A</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mi>B</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">eval \; ((\text{fun} \; x \rightarrow x) \; A) \; ((\text{fun} \; y \rightarrow A) \; B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mi>A</mi><mtext>&ThickSpace;</mtext><mo>(</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mi>A</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mi>B</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">eval \; A \; ((\text{fun} \; y \rightarrow A) \; B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mtext>&ThickSpace;</mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">A \; A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">A</span></span></span></span></p>
<p><strong>Currying</strong></p>
<p>As defined above, abstractions can accept only one input parameter. This might look limiting, since in all programming languages it is possible to write functions that accept multiple parameters. However, in functional programming, we can return other abstractions as result of an abstraction to overcome this limitation. Consider the following method in C#:</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y</span>)</span>
{
  <span class="hljs-keyword">return</span> x + y;
}
</div></code></pre>
<p>Assuming that arithmetic operators are available in lambda calculus (see the remark below for this),  we can build a function that takes <code>x</code> as parameter and whose body contains <strong>another abstraction</strong> that accepts <code>y</code> as parameter and finally computes  <code>x + y</code> in its body:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mi>x</mi><mo>+</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\text{fun} \; x \rightarrow \text{fun} \; y \rightarrow x + y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p>
<p>Now, let us actually test that this behaves as expected:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mn>5</mn><mo>)</mo><mtext>&ThickSpace;</mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">((\text{fun} \; x \rightarrow \text{fun} \; y \rightarrow x + y) \; 5) \; 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">3</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mn>5</mn><mo>+</mo><mi>y</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">(\text{fun} \; y \rightarrow 5 + y) \; 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">3</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">5 + 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></p>
<p>This mechanism is known as <em>currying</em>: the arguments to the abstraction are substituted one by one and replaced sequentially. Since the outer abstraction body contains another lambda, when we perform the first substitution, the result will be another abstraction whose body contains the inlined value 5 and the argument variable <code>y</code>. At the next function application, the parameter <code>y</code> of this second abstraction will be replaced by 3.</p>
<p>This can be seen as a mechanism where the outer abstraction can produce infinitely many abstractions as result that are capable to add any number to 5 (but to 5 only!).</p>
<p>For compactness, from now on, the following verbose notation</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>fun</mtext><mtext>&ThickSpace;</mtext><msub><mi>x</mi><mn>1</mn></msub><mo>→</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><msub><mi>x</mi><mn>2</mn></msub><mo>→</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>→</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><msub><mi>x</mi><mi>n</mi></msub><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\text{fun} \; x_1 \rightarrow \text{fun} \; x_2 \rightarrow ... \rightarrow \text{fun} \; x_n \rightarrow t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span></p>
<p>will be shortened into</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>fun</mtext><mtext>&ThickSpace;</mtext><msub><mi>x</mi><mn>1</mn></msub><mtext>&ThickSpace;</mtext><msub><mi>x</mi><mn>2</mn></msub><mtext>&ThickSpace;</mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext>&ThickSpace;</mtext><msub><mi>x</mi><mi>n</mi></msub><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\text{fun} \; x_1 \; x_2\;  ...\; x_n \rightarrow t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span></p>
<p>so we will not write the internal arrows and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>fun</mtext><mtext>&ThickSpace;</mtext></mrow><annotation encoding="application/x-tex">\text{fun} \;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span></span></span> symbols.</p>
<p><strong>Bindings</strong></p>
<p>Let us consider the following lambda calculus expression:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>f</mi><mtext>&ThickSpace;</mtext><mi>g</mi><mo>→</mo><mi>f</mi><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mi>A</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>g</mi><mo>→</mo><mi>g</mi><mo>)</mo><mo>→</mo><mi>A</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mo>(</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mi>A</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>g</mi><mo>→</mo><mi>g</mi><mo>)</mo><mo>)</mo><mo>→</mo><mi>A</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">((\text{fun} \; f \; g \rightarrow f (\text{fun} \; y \rightarrow A) \; (\text{fun} \; g \rightarrow g) \rightarrow A) \; ((\text{fun} \; y \rightarrow A) \; (\text{fun} \; g \rightarrow g)) \rightarrow A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span></p>
<p>The expression <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mi>A</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>g</mi><mo>→</mo><mi>g</mi><mo>)</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">(\text{fun} \; y \rightarrow A) \; (\text{fun} \; g \rightarrow g) \rightarrow A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> appears twice. Since it is inconvenient to write such a complex expression every time we need it, we would like to be able to write someting like:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>let E</mtext><mo>=</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mo>→</mo><mi>A</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>g</mi><mo>→</mo><mi>g</mi><mo>)</mo><mo>→</mo><mi>A</mi><mtext> in </mtext><mo>(</mo><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>f</mi><mtext>&ThickSpace;</mtext><mi>g</mi><mo>→</mo><mi>f</mi><mtext>&ThickSpace;</mtext><mi>E</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{let E} = (\text{fun} \; y \rightarrow A) \; (\text{fun} \; g \rightarrow g) \rightarrow A \text{ in } ((\text{fun} \; f \; g \rightarrow f \; E) \; E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">let E</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord text"><span class="mord"> in </span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<p>This construct is called <em>binding</em>. Note that this does <em>not</em> (notice the emphasis on this word) have the same semantics as variable assignment in imperative programming: a variable assignment changes the state of a program, whilst here there is no change of state (we do not have a state at all) and it is merely a renaming of expressions.</p>
<p>We now show that bindings can be expressed in the current semantics of lambda calculus without adding something new. When we have a binding in the form</p>
<pre><code><div>let x = y in t
</div></code></pre>
<p>we replace every occurrence of <code>x</code> in <code>t</code> with <code>y</code>. This allows us to use a shorter &quot;version&quot; <code>x</code> in <code>t</code> that will be replaced by its full form <code>y</code> when we need to evaluate the lambda calculus program. This is not much different than how we normally substitute variables in the substitution rule of lambda calculus. Actually, it is just the same! Thus, the semantics of <code>let</code> can be just expressed in terms of the substitution rule:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext> let </mtext><mi>x</mi><mo>=</mo><mi>y</mi><mtext> in </mtext><mi>t</mi><mo>⇒</mo><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>t</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">eval \text{ let } x = y \text{ in } t \Rightarrow eval \; (\text{fun} \; x \rightarrow t) \; y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord text"><span class="mord"> let </span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord text"><span class="mord"> in </span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p>
<p><strong>Shadowing</strong></p>
<p>Consider the following lambda calculus expression:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mtext>&ThickSpace;</mtext><mi>y</mi><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>y</mi><mtext>&ThickSpace;</mtext><mi>x</mi><mo>)</mo><mtext>&ThickSpace;</mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">(\text{fun} \; x \; y \; x \rightarrow y \; x) \; A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">A</span></span></span></span></p>
<p>One could blindly apply the substitution rule and end up with</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>y</mi><mtext>&ThickSpace;</mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">\text{fun} \; y \; x \rightarrow y \; A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">A</span></span></span></span></p>
<p>This is, however, incorrect: the scope of the outer variable <code>x</code> and the inner variable <code>x</code> is different. The <code>x</code> that we incorrectly substituted above is referring to the inner <code>x</code> parameter and not the outer. In other words, the inner <code>x</code> <em>shadows</em> the outer <code>x</code>. The correct result will, thus be</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>y</mi><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>y</mi><mtext>&ThickSpace;</mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">\text{fun} \; y \; x \rightarrow y \; x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span></span></span></span></p>
<p>For better clarity, one should imagine that the expression presented at the beginning of this paragraph was written as:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>fun</mtext><mtext>&ThickSpace;</mtext><msub><mi>x</mi><mn>1</mn></msub><mtext>&ThickSpace;</mtext><mi>y</mi><mtext>&ThickSpace;</mtext><msub><mi>x</mi><mn>2</mn></msub><mo>→</mo><mi>y</mi><mtext>&ThickSpace;</mtext><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\text{fun} \; x_1 \; y \; x_2 \rightarrow y \; x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>where it is shown explicitly that the outer parameter is different than the inner.</p>
<p><strong>A final note on lambda calculus</strong></p>
<p>Bindings are one of the many examples of language extensions that can be implemented directly in lambda calculus as it is. They are just syntax to make the language more usable but lambda calculus in its current form has the same expressive power as any regular programming language. Since this is not a theoretical course on formal computational models, we will not show here how to map every construct that we explain to lambda calculus, but we will merely acknowledge that this is possible. For instance, it is possible to build numbers, boolean, arithmetic operations, boolean operators, and conditional expressions (if-then-else) only in terms of abstractions, but we will just accept that this is possible without proving it and use them in functional languages and use them right away with their usual semantics. The only thing that we will add is a type system to lambda calculus.</p>
<h2 id="f-vs-lambda-calculus">F# vs Lambda Calculus</h2>
<p>In this section we proceed to introduce F#, the language of choice for this course, by showing how the language abstractions of lambda calculus are mapped to it. F# is a hybrid functional-imperative language. This means that in F# we can combine abstractions from functional programming with imperative statement. In this course we use its imperative part only to display something in the standard output. We choose this language over pure functional languages like Haskell because I/O operations (and not only) in such languages require the knowledge of advanced functional design patterns called <em>Monads</em> that go beyond the scope of this course.</p>
<p>Moreover, since we have not introduced typed lambda calculus yet, we will rely on the F# ability to <em>infer</em> types in the program that we write: in many functional languages type annotation is not mandatory (like, for instance, in Java or C) because the type checker of the compiler is powerful enough to understand the type of an expression most of the times (but not always, this is why it is important to manually determine the type of an expression).</p>
<p><strong>Bindings</strong></p>
<p>Bindings follow the same syntax we have defined in lambda calculus, for example:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span> <span class="hljs-keyword">in</span> x + <span class="hljs-number">1</span>
</div></code></pre>
<p>It is possible to omit the <code>in</code> keyword by breaking the line, so that the binding above becomes:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>
x + <span class="hljs-number">1</span>
</div></code></pre>
<p>Note that F# is indentation-sensitive, which means that indentation is not just a way of making your code more readable but a syntax rule itself. In the case of a binding, indentation is necessary when the expression that is bound appears in a new line. For instance, if we wanted to put 5 on a new line we would need to indent the code:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> x = 
  <span class="hljs-number">5</span>
x + <span class="hljs-number">1</span>
</div></code></pre>
<p>In this case this looks quite useless, but when we have longer expressions this could be quite convenient:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> x = 
  <span class="hljs-number">3</span> + <span class="hljs-number">5</span> * <span class="hljs-number">2</span> - % <span class="hljs-number">4</span>
x + <span class="hljs-number">1</span>
</div></code></pre>
<p><strong>Abstractions and Function Applications</strong></p>
<p>Abstractions can be defined by using the keyword <code>fun</code> as well. For example, the lambda calculus abstraction <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{fun} \; x \rightarrow x + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> would become in F#:</p>
<pre><code class="language-fsharp"><div>(<span class="hljs-keyword">fun</span> x -&gt; x + <span class="hljs-number">1</span>) <span class="hljs-number">3</span>
</div></code></pre>
<p>Naturally, if we bind an abstraction we can then apply it by using the name of the binding, such as:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> inc = <span class="hljs-keyword">fun</span> x -&gt; x + <span class="hljs-number">1</span>
<span class="hljs-keyword">in</span>
  inc <span class="hljs-number">3</span>
</div></code></pre>
<p>or in the more compact notation:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> inc = <span class="hljs-keyword">fun</span> x -&gt; x + <span class="hljs-number">1</span>
inc <span class="hljs-number">3</span>
</div></code></pre>
<p>which in lambda-calculus would become <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>i</mi><mi>n</mi><mi>c</mi><mo>→</mo><mi>i</mi><mi>n</mi><mi>c</mi><mtext>&ThickSpace;</mtext><mn>3</mn><mo>)</mo><mtext>&ThickSpace;</mtext><mo>(</mo><mtext>fun</mtext><mtext>&ThickSpace;</mtext><mi>x</mi><mo>→</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(\text{fun} \; inc \rightarrow inc \; 3) \; (\text{fun} \; x \rightarrow x + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">fun</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>. Note that shadowing works as expected in F#, so the result of the following program</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">fun</span> x -&gt; x + <span class="hljs-number">1</span>
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">fun</span> x -&gt; x - <span class="hljs-number">1</span>
f <span class="hljs-number">3</span>
</div></code></pre>
<p>will be 2 and not 4. An alternative syntax to defining abstractions is the following:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> inc x = x + <span class="hljs-number">1</span>
inc <span class="hljs-number">3</span>
</div></code></pre>
<h2 id="conditionals">Conditionals</h2>
<p>Conditionals in functional programming have a different semantics then in imperative programming. In the previous courses of development we saw that imperative languages support two different kinds of conditionals: one is a conditional <em>statement</em> and one is a conditional <em>expression</em>. Since in functional programming we have no state, the only supported conditional is the conditional expression. F# support a conditional expression with the syntax:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">if</span> condition <span class="hljs-keyword">then</span>
  thenExpr
<span class="hljs-keyword">else</span>
  elseExpr
</div></code></pre>
<p>which is much different from, for instance, its C# counterpart</p>
<pre><code class="language-csharp"><div>condition ? thenExpr : elseExpr
</div></code></pre>
<p>but they share the same semantics:</p>
<p><code>eval &lt;if C then T else E&gt;</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>&lt;if C' then T else E&gt; where eval &lt;C&gt;</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>  <code>C'</code></p>
<p><code>eval &lt;if true then T else E&gt;</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>&lt;T&gt;</code></p>
<p><code>eval &lt;if false then T else E&gt;</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>&lt;E&gt;</code></p>
<p>The following function shows the usage of the conditional expression:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> toInfinityAndBeyond =
  <span class="hljs-keyword">fun</span> x -&gt;
    <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
      x + <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>
      x - <span class="hljs-number">1</span>
</div></code></pre>
<p>Remember that conditional expressions always need and <code>else</code> expression.</p>
<h2 id="recursion">Recursion</h2>
<p>In functional programming there is no concept of loop. Indeed loops require stateful computation, as their semantics is defined as:</p>
<p><code>eval (&lt;while C do T&gt;,S)</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> <code>(&lt;if C then { T; while C do T } else { done }&gt;, S)</code></p>
<p>Functional programming can achieve an equivalent behaviour through recursive functions. In F# recursive functions are defined through the keyword <code>let rec</code>. For example, let us assume that we want to return a string containing all the numbers divisible by a number <code>n</code>. We can achieve this through a recursive function: this function starts from 1 and tests all the numbers less or equal than <code>n</code> one by one. The base case of the recursion happens when the number that we are testing is greater than the current number. In this case we simply return an empty string. Otherwise we check if the number is divisible by <code>n</code> and, if that is the case, we add it to the string:</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> getDivisors =
  <span class="hljs-keyword">fun</span> n i -&gt;
    <span class="hljs-keyword">if</span> i &gt; n <span class="hljs-keyword">then</span>
      <span class="hljs-string">""</span>
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">if</span> (n % i = <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
        i + <span class="hljs-string">" "</span> + (getDivisors n (i + <span class="hljs-number">1</span>))
      <span class="hljs-keyword">else</span>
        getDivisors n (i + <span class="hljs-number">1</span>)
</div></code></pre>
<p>Note that this function is equivalent to the following imperative code in C#:</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">string</span> <span class="hljs-title">GetDivisors</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> n</span>)</span>
{
  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">string</span> s = <span class="hljs-string">""</span>;
  <span class="hljs-keyword">while</span> (i &lt;= n)
  {
    <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)
      s += <span class="hljs-string">" "</span> + i;
  }
  <span class="hljs-keyword">return</span> s;
}
</div></code></pre>
<p>Observe how, in the case of the recursive function, we use the stack of the recursive calls to carry ahead all the information necessary for the computation instead of relying on side effects and the state. This should give the reader an idea on why recursion and loops are two sides of the same coin, and why functional programming is as computationally expressive as imperative programming. The recursive function can then be invoked, for example, as:</p>
<pre><code class="language-fsharp"><div>getDivisors <span class="hljs-number">15</span> <span class="hljs-number">1</span>
</div></code></pre>
<p>This approach is not ideal, since the second parameter that we provide in the function application should always be 1, but we ask the caller to provide it. The recursive function above can be encapsulated within another function: this function takes as parameter only the number <code>n</code> and defines <strong>internally</strong> the code of the recursive function, that can just be invoked every time by passing <code>n</code> and <code>1</code>.</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> getDivisors =
  <span class="hljs-keyword">fun</span> n -&gt;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> mkDivisors =
      <span class="hljs-keyword">fun</span> n i -&gt;
        <span class="hljs-keyword">if</span> i &gt; n <span class="hljs-keyword">then</span>
          <span class="hljs-string">""</span>
        <span class="hljs-keyword">else</span>
          <span class="hljs-keyword">if</span> (n % i = <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
            i + <span class="hljs-string">" "</span> + (getDivisors n (i + <span class="hljs-number">1</span>))
          <span class="hljs-keyword">else</span>
            getDivisors n (i + <span class="hljs-number">1</span>)
    mkDivisors n <span class="hljs-number">1</span>
</div></code></pre>
<h2 id="printing-to-the-standard-output">Printing to the standard output</h2>
<p>As said above, F# is a hybrid objected-oriented/functional programming language, thus it supports also side effects. In this course we rely on side effects only to print something to the standard output. In F# it is possible to print to the standard output in two different ways: the first is to rely, as for C#, on <code>System.Console.WriteLine</code>, while the other is by using the functions <code>printf</code> or <code>printfn</code>, which is more idiomatic.</p>
<p>The function <code>printf</code> (and in the same <code>printfn</code>, with the only difference that a new line is added at the end) takes as input a <em>formatted string</em>. A formatted string contains regular text, as well as formatting information, that allows to inline the string representation of its parameters. The function can take a variable number of parameters, so it is possible to pass as many parameters as necessary. For example:</p>
<pre><code class="language-fsharp"><div>printf <span class="hljs-string">"The city of %s was founded in %d %s and is %f KM far from Rotterdam"</span> 
  <span class="hljs-string">"Rome"</span> <span class="hljs-number">748</span> <span class="hljs-string">"BC"</span> <span class="hljs-number">1615.0</span>
</div></code></pre>
<p>One useful format parameter is <code>%A</code>, which is basically capable of generating a string for each data structure defined in F# (unless it is a <code>class</code>, but we are not going to use them in this course).</p>
<p>For a more comprehensive list of formatting parameters, visit <a href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.printf-module-%5Bfsharp%5D">MSDN</a></p>
<h2 id="summary">Summary</h2>
<p>In this unit we started by describing the differences between imperative and functional programming. We showed that functional programming involves <em>stateless computation</em> as functional program consists of a sequence of expressions that are evaluated, rather than a sequence of instructions that change a state. We hinted that this has the benefit that the result of a program never depends on the order of evaluation of its expressions or function calls.</p>
<p>We then proceeded to outline the model that embraces all functional programming languages, called <em>lambda calculus</em>. In this unit we presented the semantics of the untyped version of this model.</p>
<p>We then introduced the functional programming language F# and show how to map constructs from lambda calculus in it.</p>
<h1 id="exercises">Exercises</h1>
<h2 id="exercise-1">Exercise 1</h2>
<p>Implement a function</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> allNumber (n: int) : string =
</div></code></pre>
<p>that returns a string containing all numbers from 0 to n. Separate the numbers with a white space.</p>
<h2 id="exercise-2">Exercise 2</h2>
<p>Implement a function</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> allNumberRev (n: int) : string
</div></code></pre>
<p>that returns a string containing all numbers from n to 0. Separate the numbers with a white space.</p>
<h2 id="exercise-3">Exercise 3</h2>
<p>Implement a function</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> allNumberRange (lower: int) (upper: int) : string
</div></code></pre>
<p>that returns a string containing all numbers from n to 0. Separate the numbers with a white space.</p>
<h2 id="exercise-4">Exercise 4</h2>
<p>Implement a function</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> allNumberRangeRev (lower: int) (upper: int) : string
</div></code></pre>
<p>that returns a string containing all numbers between lower and upper in reverse order. Separate the numbers with a white space.</p>
<h2 id="exercise-5">Exercise 5</h2>
<p>Implement a function</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> allEvenRange (lower: int) (upper: int) : string
</div></code></pre>
<p>that returns a string containing all even numbers between lower and upper. Separate the numbers with a white space.</p>
<h2 id="exercise-6">Exercise 6</h2>
<p>Implement a function</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> drawLine (length: int) : string
</div></code></pre>
<p>that returns a string containing length asterisks.</p>
<h2 id="exercise-7">Exercise 7</h2>
<p>Implement a function</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> drawSymbols (symbol: char) (length: int) : string
</div></code></pre>
<p>that returns a string containing length repetitions of symbol.</p>
<h2 id="exercise-8">Exercise 8</h2>
<p>Implement a function</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> toBinary (n: int) : string
</div></code></pre>
<p>that returns a string containing the binary representation of the input number (it must be positive).
The binary representation is obtained using the following procedure:</p>
<ol>
<li>Add to the end of the string the remainder of the division between the current number and 2.</li>
<li>Repeat the previous step with <code>n / 2</code> until the number is 0. In this case simply don't add anything.</li>
</ol>
<h2 id="exercise-9">Exercise 9</h2>
<p>Implement a function</p>
<pre><code class="language-fsharp"><div><span class="hljs-keyword">let</span> toBase (n: int) (<span class="hljs-keyword">base</span>: int) : string
</div></code></pre>
<p>that returns a string containing the representation of the input number in an arbitrary base (the number must be positive). The algorithm is the same as above except you must take the remainder of <code>n</code> divided by <code>base</code> and pass <code>n / base</code> to the next step.</p>

    </body>
    </html>